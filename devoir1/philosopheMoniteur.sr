/* This SR file was generated by m2sr */
# 1 "/tmp/m2sr13073.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/tmp/m2sr13073.c"
# 1 "/tmp/m2sr13073.c"
/*--1 --*/ global philosophes
  type etatPossible = enum (pense, afaim, mange)
  const yo:=777
/*--4 --*/ body philosophes; type m_cv_type = rec( m_wait: cap(return_to_caller:cap(); rank: int); m_wait_ranks: cap(rank : int); m_signal: cap() returns proc_waiting:bool; m_signal_all: cap(); m_empty: cap() returns results:bool; m_minrank: cap() returns rank:int; m_print: cap(); ); op m_condvar( name:string[*]) returns m_cv : m_cv_type; sem m_mutex:=1; op m_urgentq(); var m_n_urgentq:=0; V(m_mutex); P(m_mutex); V(m_urgentq); P(m_urgentq)
  var etat[5]: etatPossible

/*--7 --*/ proc m_condvar(name) returns m_cv; op m_wait(return_to_caller:cap(); rank: int); op m_wait_ranks(rank : int); op m_signal() returns proc_waiting:bool; op m_signal_all(); op m_empty() returns results:bool; op m_minrank() returns rank:int; op m_print(); m_cv.m_wait:=m_wait; m_cv.m_wait_ranks:=m_wait_ranks; m_cv.m_signal:=m_signal; m_cv.m_signal_all:=m_signal_all; m_cv.m_empty:=m_empty; m_cv.m_minrank:=m_minrank; m_cv.m_print:=m_print; reply; do true -> in m_wait(return_to_caller, rank) and ?m_signal != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; in m_signal() returns pw -> pw:=true; m_n_urgentq++; ni; send return_to_caller(); [] m_signal() returns pw and ?m_wait = 0 -> pw:=false; [] m_wait(return_to_caller, rank) and ?m_signal_all != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; send return_to_caller(); [] m_signal_all() and ?m_wait = 0 -> skip [] m_empty() returns results -> results:=(?m_wait = 0); [] m_minrank() returns ret -> if ?m_wait_ranks != 0 -> in m_wait_ranks( rank) by rank -> send m_wait_ranks( rank); ret:=rank; ni [] else -> write("\t**** minrank called on empty Q ****"); flush(stdout); ret:=999999; fi [] m_print() -> writes("\t**** Printing for ", name, " **** "); var x:=?m_wait; writes(x, " waiting process(es)"); if x > 0 ->; var r, minr: int; var same:=true; receive m_wait_ranks(r); minr:=r; send m_wait_ranks(minr); fa i:=2 to x -> receive m_wait_ranks(r); send m_wait_ranks(r); same:=same and (r = minr); af; if same -> writes( ", all with rank ", r ); [] else -> op order(rank:int); write( ", with ranks:" ); fa i:=1 to x -> in m_wait_ranks( rank) by rank -> writes(" ", rank); send order( rank) ni; af; fa i:=1 to x -> in order( rank) -> send m_wait_ranks( rank) ni; af; fi; fi; write(); flush(stdout); ni; od; end; end


resource hello()
 import philosophes
 write("Yo", yo)
end

/* This SR file was generated by m2sr */
# 1 "/tmp/m2sr48678.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/tmp/m2sr48678.c"
# 1 "/tmp/m2sr48678.c"
/*--1 --*/ global philosophes
  type etatPossible = enum (PENSE, AFAIM, MANGE)
  op prendre(i:int), deposer(i:int)
/*--4 --*/ body philosophes; type m_cv_type = rec( m_wait: cap(return_to_caller:cap(); rank: int); m_wait_ranks: cap(rank : int); m_signal: cap() returns proc_waiting:bool; m_signal_all: cap(); m_empty: cap() returns results:bool; m_minrank: cap() returns rank:int; m_print: cap(); ); op m_condvar( name:string[*]) returns m_cv : m_cv_type; sem m_mutex:=1; op m_urgentq(); var m_n_urgentq:=0; V(m_mutex); P(m_mutex); V(m_urgentq); P(m_urgentq)
  op test(k:int) returns libre: bool
  var etat[5]: etatPossible:=([5] PENSE)
  /*--7 --*/ var attente [5] : m_cv_type; fa i:=lb(attente) to ub(attente) -> var si: string[20]; sprintf(si, "[%d]", int(i)); attente[i]:=m_condvar( "attente" || si ) af

  /*--9 --*/ proc prendre(i) op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    etat[i+1]:=AFAIM;
    test(i)
    if etat[i+1] != MANGE -> /*--12 --*/ send attente[i+1].m_wait(m_return_from_wait,0); send attente[i+1].m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex(); fi
  /*--13 --*/ send m_mutex(); end

  /*--15 --*/ proc deposer(i) op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    etat[i+1]:=PENSE;
    var k:=(i+1) mod 5
    if (test(k)) -> /*--18 --*/ m_bozo:=attente[k+1].m_signal(); fi
    k:=(i-1) mod 5
    if (test(k)) -> /*--20 --*/ m_bozo:=attente[k+1].m_signal(); fi
  /*--21 --*/ send m_mutex(); end

  proc test(k) returns libre
    libre:=false
    if (etat[(k+1) mod 5 +1] != MANGE and (etat[k+1] = AFAIM) and (etat[(k-1) mod 5 +1] != MANGE)) ->
      etat[k+1]:=MANGE
      libre:=true
    fi
  end
/*--30 --*/ proc m_condvar(name) returns m_cv; op m_wait(return_to_caller:cap(); rank: int); op m_wait_ranks(rank : int); op m_signal() returns proc_waiting:bool; op m_signal_all(); op m_empty() returns results:bool; op m_minrank() returns rank:int; op m_print(); m_cv.m_wait:=m_wait; m_cv.m_wait_ranks:=m_wait_ranks; m_cv.m_signal:=m_signal; m_cv.m_signal_all:=m_signal_all; m_cv.m_empty:=m_empty; m_cv.m_minrank:=m_minrank; m_cv.m_print:=m_print; reply; do true -> in m_wait(return_to_caller, rank) and ?m_signal != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; in m_signal() returns pw -> pw:=true; m_n_urgentq++; ni; send return_to_caller(); [] m_signal() returns pw and ?m_wait = 0 -> pw:=false; [] m_wait(return_to_caller, rank) and ?m_signal_all != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; send return_to_caller(); [] m_signal_all() and ?m_wait = 0 -> skip [] m_empty() returns results -> results:=(?m_wait = 0); [] m_minrank() returns ret -> if ?m_wait_ranks != 0 -> in m_wait_ranks( rank) by rank -> send m_wait_ranks( rank); ret:=rank; ni [] else -> write("\t**** minrank called on empty Q ****"); flush(stdout); ret:=999999; fi [] m_print() -> writes("\t**** Printing for ", name, " **** "); var x:=?m_wait; writes(x, " waiting process(es)"); if x > 0 ->; var r, minr: int; var same:=true; receive m_wait_ranks(r); minr:=r; send m_wait_ranks(minr); fa i:=2 to x -> receive m_wait_ranks(r); send m_wait_ranks(r); same:=same and (r = minr); af; if same -> writes( ", all with rank ", r ); [] else -> op order(rank:int); write( ", with ranks:" ); fa i:=1 to x -> in m_wait_ranks( rank) by rank -> writes(" ", rank); send order( rank) ni; af; fa i:=1 to x -> in order( rank) -> send m_wait_ranks( rank) ni; af; fi; fi; write(); flush(stdout); ni; od; end; end


resource philo()
 import philosophes
  process phil(i:=0 to 4)
     var j:=0
     do j < 10 ->
       philosophes.prendre(i)
       write("Philosophe", i+1, "mange")
       nap(int(random(1)*100))
       philosophes.deposer(i)
       write("Philosophe", i+1, "pense")
       nap(int(random(1)*300))
       j++
     od
  end
end

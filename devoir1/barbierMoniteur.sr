/* This SR file was generated by m2sr */
# 1 "/tmp/m2sr49143.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/tmp/m2sr49143.c"
# 1 "/tmp/m2sr49143.c"
/*--1 --*/ global boutique
  type etat = enum (DORT, ATTEND, COUPE, DEPLACEMENT, PORTE)
  const NBPLACES:int:=5
  const TOTALCLIENT:int:=10
  var nbClients:int:=0
  op appelerClient(), ouvrirPorte(), fermerPorte(), deplacer(i:int), arreter(i:int; activite:etat), clientArrive() returns attente:bool, attendreTour(), signalerPret(), attendrePorte(), sortir()
/*--7 --*/ body boutique; type m_cv_type = rec( m_wait: cap(return_to_caller:cap(); rank: int); m_wait_ranks: cap(rank : int); m_signal: cap() returns proc_waiting:bool; m_signal_all: cap(); m_empty: cap() returns results:bool; m_minrank: cap() returns rank:int; m_print: cap(); ); op m_condvar( name:string[*]) returns m_cv : m_cv_type; sem m_mutex:=1; op m_urgentq(); var m_n_urgentq:=0; V(m_mutex); P(m_mutex); V(m_urgentq); P(m_urgentq)
  /*--8 --*/ var reveil: m_cv_type; reveil:=m_condvar("reveil")
  /*--9 --*/ var clientPret: m_cv_type; clientPret:=m_condvar("clientPret")
  /*--10 --*/ var deplacement: m_cv_type; deplacement:=m_condvar("deplacement")
  /*--11 --*/ var porteSortie: m_cv_type; porteSortie:=m_condvar("porteSortie")
  /*--12 --*/ var salleAttente: m_cv_type; salleAttente:=m_condvar("salleAttente")
  /*--13 --*/ var clientSorti: m_cv_type; clientSorti:=m_condvar("clientSorti")

  var etatBarbier:etat:=DORT
  var etatClient[TOTALCLIENT]:etat:=([TOTALCLIENT] DORT)

  /*--18 --*/ proc deplacer(i) op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    var deplacementEnCours:bool:=false
    fa k:=1 to TOTALCLIENT ->
      if (etatClient[k] = DEPLACEMENT) -> deplacementEnCours:=true fi
    af
    if (etatBarbier = DEPLACEMENT) -> deplacementEnCours:=true fi
    if (deplacementEnCours) -> /*--24 --*/ send deplacement.m_wait(m_return_from_wait,0); send deplacement.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex(); fi
    if (i = 0) -> etatBarbier:=DEPLACEMENT
    []else -> etatClient[i]:=DEPLACEMENT
    fi
  /*--28 --*/ send m_mutex(); end

  /*--30 --*/ proc arreter(i, activite) op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    if (i = 0) -> etatBarbier:=activite
    []else -> etatClient[i]:=activite
    fi
    /*--34 --*/ m_bozo:=deplacement.m_signal();
  /*--35 --*/ send m_mutex(); end

  /*--37 --*/ proc appelerClient() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    if (nbClients = 0) ->
      write("Le barbier s'endort")
      etatBarbier:=DORT
      /*--41 --*/ send reveil.m_wait(m_return_from_wait,0); send reveil.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
      write("Le barbier se reveille")
    []else ->
      /*--44 --*/ m_bozo:=salleAttente.m_signal();
    fi
    etatBarbier:=ATTEND
    /*--47 --*/ send clientPret.m_wait(m_return_from_wait,0); send clientPret.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
    etatBarbier:=COUPE
  /*--49 --*/ send m_mutex(); end

  /*--51 --*/ proc ouvrirPorte() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--52 --*/ m_bozo:=porteSortie.m_signal();
  /*--53 --*/ send m_mutex(); end

  /*--55 --*/ proc fermerPorte() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--56 --*/ send clientSorti.m_wait(m_return_from_wait,0); send clientSorti.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
  /*--57 --*/ send m_mutex(); end

  /*--59 --*/ proc sortir() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--60 --*/ m_bozo:=clientSorti.m_signal();
  /*--61 --*/ send m_mutex(); end

  /*--63 --*/ proc clientArrive() returns attente op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    attente:=true
    if (etatBarbier = DORT) ->
      /*--66 --*/ m_bozo:=reveil.m_signal();
      attente:=false
    fi
  /*--69 --*/ send m_mutex(); end

  /*--71 --*/ proc attendreTour() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--72 --*/ send salleAttente.m_wait(m_return_from_wait,0); send salleAttente.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
  /*--73 --*/ send m_mutex(); end

  /*--75 --*/ proc signalerPret() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--76 --*/ m_bozo:=clientPret.m_signal();
  /*--77 --*/ send m_mutex(); end

  /*--79 --*/ proc attendrePorte() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--80 --*/ send porteSortie.m_wait(m_return_from_wait,0); send porteSortie.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
  /*--81 --*/ send m_mutex(); end

/*--83 --*/ proc m_condvar(name) returns m_cv; op m_wait(return_to_caller:cap(); rank: int); op m_wait_ranks(rank : int); op m_signal() returns proc_waiting:bool; op m_signal_all(); op m_empty() returns results:bool; op m_minrank() returns rank:int; op m_print(); m_cv.m_wait:=m_wait; m_cv.m_wait_ranks:=m_wait_ranks; m_cv.m_signal:=m_signal; m_cv.m_signal_all:=m_signal_all; m_cv.m_empty:=m_empty; m_cv.m_minrank:=m_minrank; m_cv.m_print:=m_print; reply; do true -> in m_wait(return_to_caller, rank) and ?m_signal != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; in m_signal() returns pw -> pw:=true; m_n_urgentq++; ni; send return_to_caller(); [] m_signal() returns pw and ?m_wait = 0 -> pw:=false; [] m_wait(return_to_caller, rank) and ?m_signal_all != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; send return_to_caller(); [] m_signal_all() and ?m_wait = 0 -> skip [] m_empty() returns results -> results:=(?m_wait = 0); [] m_minrank() returns ret -> if ?m_wait_ranks != 0 -> in m_wait_ranks( rank) by rank -> send m_wait_ranks( rank); ret:=rank; ni [] else -> write("\t**** minrank called on empty Q ****"); flush(stdout); ret:=999999; fi [] m_print() -> writes("\t**** Printing for ", name, " **** "); var x:=?m_wait; writes(x, " waiting process(es)"); if x > 0 ->; var r, minr: int; var same:=true; receive m_wait_ranks(r); minr:=r; send m_wait_ranks(minr); fa i:=2 to x -> receive m_wait_ranks(r); send m_wait_ranks(r); same:=same and (r = minr); af; if same -> writes( ", all with rank ", r ); [] else -> op order(rank:int); write( ", with ranks:" ); fa i:=1 to x -> in m_wait_ranks( rank) by rank -> writes(" ", rank); send order( rank) ni; af; fa i:=1 to x -> in order( rank) -> send m_wait_ranks( rank) ni; af; fi; fi; write(); flush(stdout); ni; od; end; end


resource boutiqueBarbier()
 import boutique

  process barbier
     do true ->
      boutique.appelerClient()
      write("Barbier travaille")
      nap(int(random(1)*400))

      boutique.deplacer(0)
      write("Le barbier va ouvrir la porte")
      nap(5)
      boutique.arreter(0, boutique.PORTE)
      boutique.ouvrirPorte()
      write("La porte de sortie est ouverte")
      boutique.fermerPorte()
      write("La porte de sortie est ferme")
      boutique.deplacer(0)
      write("Le barbier retourne devant sa chaise")
      nap(5)
      boutique.arreter(0, boutique.ATTEND)

     od
  end

  process client(i:=1 to boutique.TOTALCLIENT)
     var j:=0
     do j < 10 ->
       nap(int(random(1)*500))
       boutique.nbClients++
       write("Le client", i, "arrive")
       if (boutique.nbClients > boutique.NBPLACES +1) ->
         write("La boutique est pleine, le client", i, "part")
         boutique.nbClients--
         next
       [](boutique.clientArrive()) ->
         boutique.deplacer(i)
         write("Le client", i, "se deplace vers une chaise de la salle d'attente")
         nap(5)
         boutique.arreter(i, boutique.ATTEND)
         write("Le client", i, "attend son tour sur une chaise dans la salle d'attente")
         boutique.attendreTour()
       fi
       boutique.deplacer(i)
       write("Le client", i, "se deplace vers la chaise du barbier")
       nap(5)
       boutique.arreter(i, boutique.COUPE)
       boutique.signalerPret()
       write("Le client", i, "est assis sur la chaise du barbier")

       boutique.attendrePorte()
       boutique.deplacer(i)
       write("Le client", i, "sort de la boutique")
       nap(5)
       boutique.arreter(i, boutique.DORT)
       boutique.nbClients--
       boutique.sortir()

       j++
     od
  end
end

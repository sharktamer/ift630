/* This SR file was generated by m2sr */
# 1 "/tmp/m2sr33789.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/tmp/m2sr33789.c"
# 1 "/tmp/m2sr33789.c"
/*--1 --*/ global attraction
  const C:=5
  type etatPossible = enum (VIDE, PLEIN, ATTENTE)
  op demarrer(), terminer(), embarquer(), debarquer()
/*--5 --*/ body attraction; type m_cv_type = rec( m_wait: cap(return_to_caller:cap(); rank: int); m_wait_ranks: cap(rank : int); m_signal: cap() returns proc_waiting:bool; m_signal_all: cap(); m_empty: cap() returns results:bool; m_minrank: cap() returns rank:int; m_print: cap(); ); op m_condvar( name:string[*]) returns m_cv : m_cv_type; sem m_mutex:=1; op m_urgentq(); var m_n_urgentq:=0; V(m_mutex); P(m_mutex); V(m_urgentq); P(m_urgentq)
  var nbPassagers:=0
  var nbAttentes:=0
  var etat:etatPossible:=VIDE
  /*--9 --*/ var plein: m_cv_type; plein:=m_condvar("plein")
  /*--10 --*/ var vide: m_cv_type; vide:=m_condvar("vide")
  /*--11 --*/ var embarquement: m_cv_type; embarquement:=m_condvar("embarquement")
  /*--12 --*/ var debarquement: m_cv_type; debarquement:=m_condvar("debarquement")

  /*--14 --*/ proc demarrer() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    fa i:=1 to C -> /*--15 --*/ m_bozo:=embarquement.m_signal(); af
    /*--16 --*/ send plein.m_wait(m_return_from_wait,0); send plein.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
  /*--17 --*/ send m_mutex(); end

  /*--19 --*/ proc terminer() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    fa i:=1 to C -> /*--20 --*/ m_bozo:=debarquement.m_signal(); af
    /*--21 --*/ send vide.m_wait(m_return_from_wait,0); send vide.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
  /*--22 --*/ send m_mutex(); end

  /*--24 --*/ proc embarquer() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    if (nbAttentes = 0 and etat != PLEIN) ->
      nbPassagers++
    []else ->
      nbAttentes++
      /*--29 --*/ send embarquement.m_wait(m_return_from_wait,0); send embarquement.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
      nbAttentes--
      nbPassagers++
      etat:=ATTENTE
    fi
    if (nbPassagers = C) ->
      etat:=PLEIN
      /*--36 --*/ m_bozo:=plein.m_signal();
    fi
  /*--38 --*/ send m_mutex(); end

  /*--40 --*/ proc debarquer() op m_return_from_wait(); send m_return_from_wait(); receive m_return_from_wait(); receive m_mutex(); var m_bozo: bool; m_bozo:=m_bozo
    /*--41 --*/ send debarquement.m_wait(m_return_from_wait,0); send debarquement.m_wait_ranks(0); send m_mutex(); receive m_return_from_wait(); receive m_mutex();
    nbPassagers--
    if(nbPassagers = 0) ->
      etat:=VIDE
      /*--45 --*/ m_bozo:=vide.m_signal();
    fi
  /*--47 --*/ send m_mutex(); end

/*--49 --*/ proc m_condvar(name) returns m_cv; op m_wait(return_to_caller:cap(); rank: int); op m_wait_ranks(rank : int); op m_signal() returns proc_waiting:bool; op m_signal_all(); op m_empty() returns results:bool; op m_minrank() returns rank:int; op m_print(); m_cv.m_wait:=m_wait; m_cv.m_wait_ranks:=m_wait_ranks; m_cv.m_signal:=m_signal; m_cv.m_signal_all:=m_signal_all; m_cv.m_empty:=m_empty; m_cv.m_minrank:=m_minrank; m_cv.m_print:=m_print; reply; do true -> in m_wait(return_to_caller, rank) and ?m_signal != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; in m_signal() returns pw -> pw:=true; m_n_urgentq++; ni; send return_to_caller(); [] m_signal() returns pw and ?m_wait = 0 -> pw:=false; [] m_wait(return_to_caller, rank) and ?m_signal_all != 0 by rank -> in m_wait_ranks(rank) by rank -> ni; send return_to_caller(); [] m_signal_all() and ?m_wait = 0 -> skip [] m_empty() returns results -> results:=(?m_wait = 0); [] m_minrank() returns ret -> if ?m_wait_ranks != 0 -> in m_wait_ranks( rank) by rank -> send m_wait_ranks( rank); ret:=rank; ni [] else -> write("\t**** minrank called on empty Q ****"); flush(stdout); ret:=999999; fi [] m_print() -> writes("\t**** Printing for ", name, " **** "); var x:=?m_wait; writes(x, " waiting process(es)"); if x > 0 ->; var r, minr: int; var same:=true; receive m_wait_ranks(r); minr:=r; send m_wait_ranks(minr); fa i:=2 to x -> receive m_wait_ranks(r); send m_wait_ranks(r); same:=same and (r = minr); af; if same -> writes( ", all with rank ", r ); [] else -> op order(rank:int); write( ", with ranks:" ); fa i:=1 to x -> in m_wait_ranks( rank) by rank -> writes(" ", rank); send order( rank) ni; af; fa i:=1 to x -> in order( rank) -> send m_wait_ranks( rank) ni; af; fi; fi; write(); flush(stdout); ni; od; end; end


resource parc()
 import attraction
  const N:=16
  process voiture
    do true ->
      write("Voiture prete pour l'embarquement")
      attraction.demarrer()
      write("Debut des 5 tours de piste")
      fa i:=1 to 5 -> nap(100) af
      write("Fin des tours")
      attraction.terminer()
    od
  end

  process passager(i:=1 to N)
     var j:=0
     do j < 10 ->
       write("Passager", i, "attend pour embarquer")
       attraction.embarquer()
       write("Passager", i, "dans la voiture")
       attraction.debarquer()
       j++
     od
  end
end
